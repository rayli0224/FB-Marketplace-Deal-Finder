---
description: Frontend conventions — imports, styling constants, component abstraction, and React patterns
globs: frontend/**/*.{ts,tsx}
alwaysApply: false
---

# Frontend Conventions

## Styling Constants

- **Share as many UI constants as possible.** Put **generic** style/class strings (layout, typography, colors, borders, reusable component patterns) in a dedicated shared module (e.g. under lib or config). Constants there must be generic—reusable across multiple components or screens. Import and use them instead of duplicating style strings in markup.
- **Bespoke constants live in the component that uses them.** If a constant is specific to one component (or used only there), define it at the top of that component file. Do not add a separate constants file in the same directory (e.g. no `feature/constants.ts`); keep bespoke constants colocated with the component.
- **Consistent text and tokens.** Use shared design tokens or style constants for content text (e.g. brightness, size variants) so appearance is consistent; avoid one-off muted or opacity variants for body content unless they are part of the design system.
- **Group constants by concern.** Put timing/intervals in a module named for that concern (e.g. timing, intervals); put styling in a styling-focused module. Animation or component-specific config (e.g. keyframe names, transform origin) may stay at the top of the component file if used only there.
- **No generic constants file.** Use specific module names that describe the content (e.g. styling, timing). Do not add a catch-all like `constants.ts`; it creates semantic confusion with the specific modules.

## Import Paths

- **Prefer absolute import paths** using the project's path alias (e.g. `@/` or similar)
- Avoid deep relative imports across many levels; use the alias for clarity and refactor-safety

## Component Abstraction

### When to Extract
- **Reusable UI patterns**: UI elements that appear in multiple places
- **Complex UI structures**: JSX sections over 20 lines with a clear purpose
- **Reusable interactions**: Components with their own state/behavior
- **UI primitives**: Buttons, modals, toggles, inputs

### Organization
- Reusable UI primitives go in a shared UI directory (e.g. `components/ui/` or equivalent)
- Domain- or feature-specific components go in subdirectories that match the feature
- Each component should have a single, focused responsibility

### Structure
- All components must have TypeScript interfaces for props
- Include docstrings explaining what the component does and how to use it
- Export both the component and its props interface

### Naming
- Use semantically clear names that describe what the component does or represents
- Avoid technical jargon or ambiguous terms (e.g., `OverlayPanel` instead of `Modal`)
- Names should be self-explanatory without needing to read the implementation
- Prefer descriptive names over generic ones so the component's role is clear from the name
