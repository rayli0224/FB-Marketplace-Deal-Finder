---
description: Core coding standards — naming, structure, documentation, and general principles
alwaysApply: true
---

# Coding Standards

## Function Naming

- Function names must clearly communicate what the function does, even without context
- Names should be descriptive enough that a reader understands the function's purpose
- Avoid vague or ambiguous names
- Functions that attempt an operation that may fail should use prefixes like `try_`
- For extraction functions, follow the pattern: `_try_extract_<what>_<how>`
  - Example: `_try_extract_title_with_selectors`, `_try_extract_title_by_dom_structure`

## Function Size and Structure

- When functions become large or complex, break them into smaller helper functions
- Each function should have a single, focused responsibility
- Keep related functions together
- Main functions should orchestrate helpers rather than contain all logic

## Documentation

### Docstrings
- All functions should have docstrings explaining **what** it does and **how** it does it
- A plain description paragraph is sufficient — omit Args, Returns, and Example sections unless they add real value
- Do not assume the reader has context — docstrings should be understandable on their own
- **Do not reference other function names** — describe the behavior inline instead of saying "delegates to X" or "calls Y"
- Include implementation details that aren't obvious from reading the code
- Explain technical decisions or non-obvious patterns
- Be clear and comprehensive, prioritizing understanding over brevity

### Comments
- Remove comments that don't add value
- Comments should explain "why" or provide context, not restate what the code does
- Keep comments that explain non-obvious logic, important context, or design decisions

## Abstractions

- **Clear abstractions.** Do not mix multiple concerns in one module or class. Each module/class should have a single, well-defined responsibility.
- **Extract distinct concerns into their own modules.** If a file does two different kinds of work, split them: put each concern in a dedicated module and have the caller use both. Do not embed one concern inside another.
- **Name modules by what they own.** The filename or module name should describe its responsibility. When adding new behavior, ask: does this belong here, or in a separate abstraction?
- **No generic file when a specific one exists.** If you have (or introduce) specific-named modules for specific concerns, do not create a generic-named module for the same kind of content. Use only specific names so it's clear where things go and avoid semantic confusion.
- **Prefer "X uses Y" over "X does Y and Z".** A module that needs another capability should depend on a dedicated module for it, not implement that capability itself.

## Constants and Literals

- **Define constants at the top of the file** (after imports). Group and order them so they are easy to find and change.
- **Avoid magic numbers and string literals** where meaning would be unclear. Use named constants (or enums) so the purpose is obvious and values can be changed in one place.
- Use constants for: numeric or string values that represent configuration (durations, sizes, limits), repeated literals, and any value whose meaning isn’t obvious from context.
- **Styling constants**: Shared UI styling must be abstracted. Put **generic** (reusable) style/class strings in a dedicated shared module and import where needed. Constants that are not generic—specific to one component or feature—go in that file instead of the shared one.

## Dead Code and Unused Logic

- **Delete code that is no longer used.** If something is no longer part of core logic (e.g. a replaced feature, a removed UI path, or an obsolete helper), remove it rather than leaving it in the codebase. This includes unused components, types, handlers, and files.
- Do not keep "might use later" or deprecated code; remove it. Version control preserves history if needed.

## Code Organization

- Prefer robust, maintainable solutions over fragile, clever code
- **No fallbacks**: Do not add fallback code paths (e.g. "if X fails, try Y instead"). Fix the root cause so the primary path works every time. Configure the environment, dependencies, or design so the intended behavior is the only path.
- **Zero fallback selectors**: Use exactly one selector per UI target (e.g. one button, one input). Do not maintain lists of alternative selectors; when the site changes, update the single selector. No "try selector A, then B, then C" loops.
- When dealing with unreliable external data, make the integration reliable (retries, clear errors, correct config) rather than falling back to a different strategy.
- When choosing between performance and reliability/maintainability, prefer the latter
- Document significant performance trade-offs when they're made

## User-Facing Copy

- User-visible text must be **non-technical** (no jargon in instructions or errors). Preserve the app's chosen tone and theme in the UI; see any project-specific rule for copy and voice.

## General Principles

- **Clarity over cleverness**: Write code that's easy to understand
- **Explicit over implicit**: Make intentions clear through naming and structure
- **Fail gracefully**: Handle errors and edge cases appropriately
- **Consistency**: Follow established patterns within the codebase
