# Coding Style Preferences

## Function Naming

### Self-Explanatory Names
- Function names must clearly communicate what the function does, even without context
- Names should be descriptive enough that a reader understands the function's purpose
- Avoid vague or ambiguous names

### Attempt/Trial Functions
- Functions that attempt an operation that may fail should indicate this in their name
- Use prefixes like `try_` to signal that the function might return empty/None/fail
- This helps readers understand the function's behavior and return semantics
- For extraction functions, follow the pattern: `_try_extract_<what>_<how>`
  - Example: `_try_extract_title_with_selectors`, `_try_extract_title_by_dom_structure`
  - The pattern clearly indicates: it's an attempt, what it extracts, and how it does it

## Function Size and Structure

### Breaking Down Large Functions
- When functions become large or complex, break them into smaller helper functions
- Each function should have a single, focused responsibility
- Helper functions improve maintainability, testability, and readability

### Function Organization
- Keep related functions together
- Main functions should orchestrate helpers rather than contain all logic
- Group functions by their purpose or domain

## Documentation

### Docstrings
- All functions should have docstrings that explain:
  1. **What** the function does (its purpose)
  2. **How** it accomplishes this (the approach or strategy)
- **Do not assume the reader has context** - docstrings should be understandable on their own
- Write as if the reader is encountering this function for the first time
- Include implementation details that aren't obvious from reading the code
- Explain technical decisions or non-obvious patterns (e.g., "We use a queue because...")
- Be clear and comprehensive, prioritizing understanding over brevity

### Comments
- Remove comments that don't add value
- Comments should explain "why" or provide context, not restate what the code does
- Keep comments that explain non-obvious logic, important context, or design decisions
- Code should be self-documenting through good naming and structure

## Code Organization

### Robust Solutions
- Prefer robust, maintainable solutions over fragile, clever code
- Use layered fallback strategies when dealing with unreliable external data
- Design for failure: assume things will go wrong and handle gracefully

### Trade-offs
- When given a choice between performance and reliability/maintainability, prefer the latter
- It's acceptable to trade some performance for more robust, understandable code
- Document significant performance trade-offs when they're made

## Import Paths

### Absolute Imports Only
- **Always use absolute import paths** with the `@/` prefix
- Never use relative imports (e.g., `./Component`, `../Component`)
- This makes imports consistent, easier to refactor, and clearer about where components come from
- Example: Use `@/components/search-form/MarketplaceSearchForm` instead of `./MarketplaceSearchForm` or `../search-form/MarketplaceSearchForm`

## Component Abstraction

### When to Abstract Components
- **Extract reusable UI patterns**: If a UI element appears in multiple places or could be reused, create a component
- **Complex UI structures**: If a section of JSX is complex (20+ lines) and has a clear purpose, consider extracting it
- **Reusable interactions**: Components with their own state and behavior that could be used elsewhere should be abstracted
- **UI primitives**: Common UI elements like buttons, modals, toggles, inputs should be abstracted into reusable components

### Component Organization
- Place reusable UI components in `@/components/ui/` directory
- Place domain-specific components in appropriate subdirectories (e.g., `@/components/results/`, `@/components/search-form/`)
- Use descriptive, self-explanatory component names that clearly indicate their purpose
- Each component should have a single, focused responsibility

### Component Structure
- All components should have TypeScript interfaces for props
- Include docstrings explaining what the component does and how to use it
- Export both the component and its props interface
- Use absolute imports (`@/components/...`) for all component imports

### Examples of Good Abstraction
- A toggle switch used in filters → `ToggleSwitch` component in `@/components/ui/`
- An overlay panel that appears over content → `OverlayPanel` component in `@/components/ui/`
- A form input field → `FormInputField` component (already exists)
- A complex table row with specific logic → Extract to `TableRow` component if reused

### Component Naming
- Use semantically clear names that describe what the component does or represents
- Avoid technical jargon or ambiguous terms (e.g., use `OverlayPanel` instead of `Modal`)
- Names should be self-explanatory without needing to read the implementation
- Prefer descriptive names over generic ones (e.g., `SearchResultsTable` over `Table`)

## General Principles

- **Clarity over cleverness**: Write code that's easy to understand
- **Explicit over implicit**: Make intentions clear through naming and structure
- **Fail gracefully**: Handle errors and edge cases appropriately
- **Consistency**: Follow established patterns within the codebase
