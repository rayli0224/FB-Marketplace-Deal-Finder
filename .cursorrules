# Coding Style Preferences

## Function Naming

### Self-Explanatory Names
- Function names must clearly communicate what the function does, even without context
- Names should be descriptive enough that a reader understands the function's purpose
- Avoid vague or ambiguous names

### Attempt/Trial Functions
- Functions that attempt an operation that may fail should indicate this in their name
- Use prefixes like `try_` to signal that the function might return empty/None/fail
- This helps readers understand the function's behavior and return semantics
- For extraction functions, follow the pattern: `_try_extract_<what>_<how>`
  - Example: `_try_extract_title_with_selectors`, `_try_extract_title_by_dom_structure`
  - The pattern clearly indicates: it's an attempt, what it extracts, and how it does it

## Function Size and Structure

### Breaking Down Large Functions
- When functions become large or complex, break them into smaller helper functions
- Each function should have a single, focused responsibility
- Helper functions improve maintainability, testability, and readability

### Function Organization
- Keep related functions together
- Main functions should orchestrate helpers rather than contain all logic
- Group functions by their purpose or domain

## Documentation

### Docstrings
- All functions should have docstrings that explain:
  1. **What** the function does (its purpose)
  2. **How** it accomplishes this (the approach or strategy)
- **Do not assume the reader has context** - docstrings should be understandable on their own
- Write as if the reader is encountering this function for the first time
- Include implementation details that aren't obvious from reading the code
- Explain technical decisions or non-obvious patterns (e.g., "We use a queue because...")
- Be clear and comprehensive, prioritizing understanding over brevity

### Comments
- Remove comments that don't add value
- Comments should explain "why" or provide context, not restate what the code does
- Keep comments that explain non-obvious logic, important context, or design decisions
- Code should be self-documenting through good naming and structure

## Code Organization

### Robust Solutions
- Prefer robust, maintainable solutions over fragile, clever code
- Use layered fallback strategies when dealing with unreliable external data
- Design for failure: assume things will go wrong and handle gracefully

### Trade-offs
- When given a choice between performance and reliability/maintainability, prefer the latter
- It's acceptable to trade some performance for more robust, understandable code
- Document significant performance trade-offs when they're made

## General Principles

- **Clarity over cleverness**: Write code that's easy to understand
- **Explicit over implicit**: Make intentions clear through naming and structure
- **Fail gracefully**: Handle errors and edge cases appropriately
- **Consistency**: Follow established patterns within the codebase
